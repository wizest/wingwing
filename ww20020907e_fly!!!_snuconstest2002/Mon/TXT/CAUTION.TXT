
    %컴파일 옵션 설정에서의 주의점%

 1. 볼랜드 컴파일러의 컴파일 옵션중 옵티마이징에서 스피드 옵션을 키고 컴파일하지 말것.
    디폴트 옵션으로만 해야한다.
    그렇지 않으면, 인터럽트에서 변수 억세스를 잘하지 못하는 일이 생긴다.

 2. 진입/탈출 코드 옵션에서 스탠다드 스택 프래임 옵션은 키지 말것.
    프로그램중 인터럽트 코드 작성시 테이타 세그먼트 재설정이 귀찮아서
    함수 이름 앞에 인터럽트 키워드를 쓰지 않고 있다.
    그래서 푸쉬와 팝을 함수 처음과 끝에 해주어야 하는데

    코드를 보면

        push bp         ------- 스택프래임 옵션에 의해 함수 처음에
        mov  bp, sp     __|     추가되는 코드 / 이것은 사람이 어셈코드를
                                작성시 프로그래밍을 손쉽게 하기  위해서
                                사용하는 방법이다.

    asm pusha           ------------- 프로그래중에 직접 코딩하는 곳
    ...                        |      ...에 함수 코드를 작성한다.
                               |
    asm popa                   |
    asm iret            -------

        pop  bp         -------- 스택프래임에 의해 자동 추가 되는 코드
        ret

        ===> 여기서 문제가 발생!
        ===> bp가 팝돼기 전에 작성한  iret에 의해 종료가 되면,
        ===> 복귀후에 올바른 세그먼트 값들을 갖을수 없다.

        ===> 스택프래임은 사람이 프로그래밍이나 디버깅을 손쉽게 하기 위한 방법론
             이므로 사실상 스택프래임을 쓰지 않는 것이 속도가 더 빠르다.

 3. 작성하는 코드는 188에서만 사용할수 있는 어셈으로 바뀐다.
    곱셈을 한다면 사용할수 있는 명령은 mul, imul 뿐이다. 이 명령어들은
    최대 16bit(워드크기)의 피연산자들로만 연산을 할수 있다. 따라서
    롱형 크기의 피연산자를 사용한다면 시스템이 죽는 결과가 생긴다.

    => long temp;
       word A,B;

       temp *= 1; (X)
       temp = (long)A * B; (X)
       temp = (long)(A*B); (O)

       A=(word)(temp>>14);  (X)
       A=((word*)&temp)[1]; (O)

    옵션에 보면 모든 컨스탄트 상수는 롱형으로 취급하는 옵션이 있는데 켜놓지 말것.



